# Goについて(主にTour of Goとか)

- メソッドはポインタをレシーバにすることは可能だけど、ポインタ型を変数にすることはできない
  - `func (x *MyType) some_fn() {…}` はok
  - `func (x MyType) some_fn() {…}` (ただしtype MyType *SomeType)はあかん

- &(-): T→*T, *(-): *T→Tの関数
- 受け取った変数に変更を加える関数やメソッドはポインタを用いる
(swapや2倍する関数など)
- 受け取った変数から情報を取得して演算するだけの関数はポインタ使わない

## インタフェース
- Goのインタフェースは実装が分かりにくいけど、インタフェースで指定したメソッドはすべて実装しないとエラーが出るためちゃんと暗黙的に実装をしている
- ある型があるインタフェースを実装しているかどうかは、例えばその型がインタフェース型の値に代入されようとしたりインタフェース型の返り値として使われていることより判断できる

- インタフェース型のオブジェクトは(型、値)の組と言える
(存在型は無限直和型なので値が(添字, 値)の組になる/なぜか有限個の直和型は存在しない)
- 型TのNilが代入されたインタフェース型オブジェクトは(T, Nil)みたいになる
(オブジェクトi自体はNilではない、つまりbotを潰さない通常の直和)
- 空のインタフェース型オブジェクトは任意の型のオブジェクトを「代入」できる
  - (つまり型Tの値vを型anyの値(T, v)に入射できる、ただの代入とは異なる)
  - (JavaとかにおけるObject型みたいな？)
  - $\uparrow$ fmt.Printlnはinterface{}型が引数
- もちろん、一般のインタフェース型には「条件」を満たした型の値ならなんでも代入できる


- インタフェースは存在型、structは直積型
- そのためインタフェース型の値は、実際の型と値のペアになる
- 中身付きのインタフェースはsuch that付きの存在型
- Goはジェネリクスも使えるため全称型も使える

- 結局なんでも受け取れる関数は存在型なの？全称型なの？
  - 一般には∀α.(P(α)->Q(α))だが出力に入力がαに自由だったら(∃α.P(α))->Qとなりインタフェース型の入力とも見なせる

- 型キャスト=入射？
  - インターフェース型への代入は暗黙でキャストが行われる
  - `type Int int`なInt型にint型のオブジェクトを代入するのも暗黙のキャスト
  - `var x float = float(3)`とかも部分型付(サブタイピング)は直和(a≦b⇔b=b∨a)なので入射となる

- インタフェースは(無限の)直和型なため当然一意な射(型switch、すなわち型によるパターンマッチ)が存在する
  - つまりインタフェース型の値に対してその値が保持する型によって場合分けをする機能がある
  - `i.(type)`は型スイッチの条件文でしか使えない

- Stringerやerror等のインタフェースは明示的に定義されないためString()やError()を見たら気をつける


## fmt
- fmtパッケージにはStringerインタフェースが定義されている
``` go
type Stringer interface {
	String() string
}
```
- 実際にStringerインタフェースを実装したら(=Stringメソッドを定義した型を定義したら)、`fmt.Println(x)`が自動で`fmt.Println(a.String())`として解釈される


## カプセル化
- 大文字で始まる識別子のものはpublic(=外部パッケージからアクセスできる)
- 小文字で始まる識別子のものはprivate(=外部パッケージからアクセスできない)


## いろいろ
- 関数の中で再帰関数を一時的に定義したかったら次のように書く
``` go
var f func(int) int
f = func(n int) int {fを用いた再帰的定義}
```
- mapのキーにslice([]int等)は指定できないけど、array([2]int等)なら指定できる